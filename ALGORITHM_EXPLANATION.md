# 🧮 شرح خوارزمية تجميع السجاد - CutOptimizer Algorithm

## 📋 نظرة عامة
هذا المستند يشرح بالتفصيل الخوارزمية المستخدمة في برنامج CutOptimizer لتجميع السجاد في مجموعات وفق شروط العرض والطول. الخوارزمية تعتمد على نهج **Greedy Algorithm** (الخوارزمية الجشعة) لتحقيق أفضل تجميع ممكن.

## 🎯 الهدف من الخوارزمية
تجميع قطع السجاد في مجموعات بحيث:
- **العرض الإجمالي** للمجموعة يقع ضمن النطاق المحدد `[min_width, max_width]`
- **الطول** للقطع المترابطة متقارب ضمن هامش التسامح `tolerance_length`
- **تقليل الهدر** وزيادة كفاءة الاستخدام

## 🏗️ هياكل البيانات المستخدمة

### 1. Rectangle (المستطيل)
```python
@dataclass
class Rectangle:
    id: Optional[int]      # معرف فريد للقطعة
    width: int             # العرض بالسم
    length: int            # الطول بالسم
    qty: int              # الكمية المتاحة
```

### 2. UsedItem (القطعة المستخدمة)
```python
@dataclass
class UsedItem:
    rect_id: Optional[int] # معرف القطعة الأصلية
    width: int            # العرض
    length: int           # الطول
    used_qty: int         # الكمية المستخدمة
    original_qty: int     # الكمية الأصلية
```

### 3. Group (المجموعة)
```python
@dataclass
class Group:
    id: int               # معرف المجموعة
    items: List[UsedItem] # قائمة القطع في المجموعة
    
    def total_width(self) -> int:    # العرض الإجمالي
    def ref_length(self) -> int:     # الطول المرجعي
    def total_area(self) -> int:     # المساحة الإجمالية
```

## 🔄 خطوات الخوارزمية التفصيلية

### المرحلة 1: الإعداد الأولي
```python
# 1. ترتيب القطع حسب العرض (تنازلي أو تصاعدي حسب الإعداد)
carpets_sorted = sorted(carpets, key=lambda r: r.width, reverse=start_with_largest)

# 2. إنشاء خرائط للمساعدة في البحث
id_map = {r.id: r for r in carpets_sorted}           # معرف -> قطعة
remaining_qty = {r.id: r.qty for r in carpets_sorted} # الكميات المتبقية
widths_map = defaultdict(list)                        # عرض -> قائمة المعرفات
```

### المرحلة 2: الحلقة الرئيسية للتجميع
```python
while True:
    # 1. اختيار القطعة الأساسية (Primary)
    primary = find_first_available_rectangle()
    
    if primary is None:
        break  # لا توجد قطع متاحة
        
    # 2. محاولة إنشاء مجموعة باستخدام هذه القطعة
    group_created = try_create_group(primary)
    
    if not group_created:
        handle_fallback_strategy(primary)
```

### المرحلة 3: استراتيجية إنشاء المجموعة

#### 3.1 اختيار القطعة الأساسية
- البحث عن أول قطعة متاحة بعرض ≤ `max_width`
- البدء بالأكبر إذا كان `start_with_largest = True`

#### 3.2 محاولة استخدام كميات مختلفة من القطعة الأساسية
```python
for use_primary in range(primary_avail, 0, -1):
    # حساب الطول المرجعي
    ref_total_len = primary.length * use_primary
    
    # حساب العرض المتبقي المطلوب
    min_rem = max(min_width - primary.width, 0)
    max_rem = max_width - primary.width
```

#### 3.3 البحث عن قطع مكملة
```python
# ترتيب العروض تنازلياً (تفضيل الأكبر)
candidate_widths = sorted(widths_map.keys(), reverse=True)

for width in candidate_widths:
    if chosen_width + width > max_width:
        continue  # تجاوز الحد الأقصى
        
    for rect_id in widths_map[width]:
        # حساب الكمية المطلوبة لمطابقة الطول
        desired_qty = max(1, int(round(ref_total_len / cand.length)))
        take = min(desired_qty, avail)
        
        # فحص هامش التسامح في الطول
        diff = abs(cand_total_len - ref_total_len)
        if diff <= tolerance_length:
            # إضافة القطعة للمجموعة
            chosen_items.append(UsedItem(...))
            chosen_width += width
```

### المرحلة 4: استراتيجيات الاحتياط (Fallback Strategies)

#### 4.1 إذا فشل التجميع مع شركاء
```python
if min_width <= primary.width <= max_width:
    # إنشاء مجموعة من القطعة وحدها
    create_single_item_group(primary)
else:
    # استبعاد القطعة لتجنب الحلقة اللانهائية
    remaining_qty[primary.id] = 0
```

## 🎯 المعايير الأساسية للخوارزمية

### 1. معيار العرض
- **الحد الأدنى:** `min_width` (افتراضي: 370 سم)
- **الحد الأقصى:** `max_width` (افتراضي: 400 سم)
- **الهدف:** مجموع أعراض القطع في المجموعة ضمن هذا النطاق

### 2. معيار الطول
- **هامش التسامح:** `tolerance_length` (افتراضي: 100 سم)
- **المرجع:** طول القطعة الأساسية × كمية الاستخدام
- **الهدف:** أطوال القطع المكملة قريبة من الطول المرجعي

### 3. معيار الكمية
- **الحد الأقصى للاستخدام:** الكمية المتاحة
- **الحد الأدنى:** قطعة واحدة على الأقل
- **الهدف:** استخدام أكبر كمية ممكنة من القطعة الأساسية

## 🔍 مثال تطبيقي

### البيانات المدخلة:
```
ID | العرض | الطول | الكمية
---|-------|-------|-------
1  | 126   | 170   | 182
2  | 133   | 190   | 12
3  | 145   | 200   | 130
```

### خطوات التطبيق:

#### المجموعة 1:
1. **اختيار القطعة الأساسية:** ID=3 (العرض=145)
2. **حساب الطول المرجعي:** 200 × 1 = 200
3. **البحث عن مكمل:** ID=1 (العرض=126)
4. **فحص العرض:** 145 + 126 = 271 ✓ (ضمن النطاق)
5. **فحص الطول:** |170 - 200| = 30 ✓ (ضمن التسامح)
6. **النتيجة:** مجموعة بعرض 271 وطول مرجعي 200

#### المجموعة 2:
1. **اختيار القطعة الأساسية:** ID=2 (العرض=133)
2. **حساب الطول المرجعي:** 190 × 1 = 190
3. **البحث عن مكمل:** ID=1 (العرض=126)
4. **فحص العرض:** 133 + 126 = 259 ✓
5. **فحص الطول:** |170 - 190| = 20 ✓
6. **النتيجة:** مجموعة بعرض 259 وطول مرجعي 190

## ⚡ خصائص الأداء

### التعقيد الزمني:
- **O(n² × m)** حيث:
  - `n` = عدد أنواع القطع المختلفة
  - `m` = متوسط الكمية لكل نوع

### التعقيد المكاني:
- **O(n)** للمتغيرات المساعدة
- **O(g × k)** للمجموعات الناتجة حيث `g` = عدد المجموعات، `k` = متوسط القطع لكل مجموعة

## 🎛️ المعاملات القابلة للتعديل

| المعامل | الوصف | التأثير على الخوارزمية |
|---------|--------|----------------------|
| `start_with_largest` | البدء بالأكبر | يفضل القطع الكبيرة أولاً |
| `allow_split_rows` | السماح بتقسيم الصفوف | مرونة في استخدام الكميات |
| `min_width` | الحد الأدنى للعرض | يحدد الحد الأدنى للمجموعة |
| `max_width` | الحد الأقصى للعرض | يحدد الحد الأقصى للمجموعة |
| `tolerance_length` | هامش التسامح | مرونة في مطابقة الأطوال |

## 🔧 نقاط القوة والضعف

### نقاط القوة:
- ✅ **بساطة التنفيذ** وسهولة الفهم
- ✅ **سرعة التنفيذ** مقارنة بالخوارزميات المعقدة
- ✅ **مرونة في التخصيص** عبر المعاملات
- ✅ **نتائج مقبولة** في معظم الحالات العملية

### نقاط الضعف:
- ❌ **لا يضمن الحل الأمثل** (مشكلة NP-Hard)
- ❌ **قد يترك قطعاً غير مجمعة** في بعض الحالات
- ❌ **يعتمد على ترتيب البيانات** المدخلة

## 🚀 اقتراحات للتحسين

### 1. تحسينات الخوارزمية:
- **Backtracking:** العودة للخلف عند فشل مسار معين
- **Dynamic Programming:** لحفظ الحلول الجزئية
- **Genetic Algorithm:** للبحث عن حلول أفضل

### 2. تحسينات الأداء:
- **Parallel Processing:** معالجة متوازية للمجموعات
- **Caching:** حفظ النتائج المتكررة
- **Heuristics:** قواعد إرشادية إضافية

### 3. تحسينات المرونة:
- **Multi-objective Optimization:** تحسين عدة أهداف معاً
- **Constraint Satisfaction:** مرونة أكبر في القيود
- **Machine Learning:** تعلم من البيانات السابقة

## 📊 مقاييس التقييم

### 1. كفاءة التجميع:
```
كفاءة التجميع = (عدد القطع المجمعة / إجمالي القطع) × 100%
```

### 2. معدل الهدر:
```
معدل الهدر = (مساحة القطع المتبقية / إجمالي المساحة) × 100%
```

### 3. جودة التطابق:
```
جودة التطابق = (1 - متوسط الفرق في الأطوال / الطول المتوسط) × 100%
```

---

**ملاحظة:** هذه الخوارزمية مصممة خصيصاً لمشكلة تجميع السجاد وتأخذ في الاعتبار المتطلبات العملية لصناعة السجاد مثل حدود العرض القياسية وهامش التسامح في الطول.
